컴파일할 때가 아니라 실행할 때 보는 동적바인딩

부모 클래스의 가상 함수는 상속 받는 클래스에서 구현해야 할 일종의 함수 인터페이스를 제공

"청소는하고 살아야함 ㄹㅇㅋㅋ"

실행시간 다형성

하나의 인터페이스에 서로 다른 모양의 구현

적어도 도형은 드로우는 해야 도형이다 ㅅㅂ ㅋㅋㅋ 라고 하는거


각자가 자신의 목적에 맞게  draw를 구현하는 것이다. 
자기목적에 맞는 작업을 수행


할당해주는 작업을 바인딩이라고 한다. 
정적 바인딩
컴파일과정에서 순차적으로 할당해준다. 
컴파일할때 에러나면 바로 수정가능
속도가 빠르다

컴파일이 끝나고나서 되돌릴 수 없다. 

동적 바인딩
실행시점에 결정해주는 것

실행중에 객체 내에 오버라이딩한 자식 클래스의 가상함수를 찾아 실행한다
=실행시간 바인딩

가상함수를 재정의하는 오버라이딩된 함수가 무조건 호출
자식 클래스에 대해 부모 클래스에 대한 포인터로 가상 함수를 호출하는 경우
가상함수를 호출하는 코드를 컴파일 할때 컴파일러는 바인딩을 실행시간에 결정하도록 미룬다. 




가상함수를 재정의하는 것 = 오버라이딩
그렇지 않은 경우 = 함수 재정의



가상함수를 호출하기만 해도 동적바인딩이 발생한다
외부함수에서 호출하든, 호출당하는 애가 virtural이면 무조건동적바인딩이 발생한다고 정리

부모레벨의 포인터가 자식 객체를 가리키면 업캐스팅

호출하는 함수가 virtural이면 무조건 동적바인딩


컴파일러에게 오버라이딩을 확인하도록 지시하는 것

에러는 없는데 결과는 이상할 수 있다. 

이거오버라이딩된거다 drow는 있는데 drow에 대한 부모클래스에 함수가없다는것을 판단

가상함수에 대해서 인터페이스를 제공하는 함수는 virtural
올라타는놈은 virtural 생략가능하다

생략해도 오버라이딩이라고 인식한다.
지시어는 써줘야 컴파일할때 인식할 수 있다. 

자식 클래스에서 오버라이딩을 무력화시킨다. 
나는 니가 빗자루 몽둥이를 들고 청소하길원한다
정통무시하면 빠따로 존나 쳐맞을래? ㅋㅋㅋ
= final

오버라이딩을 금지시키는 것이다. 

자식새끼가 아부지 방법 고수해라고 하는 것

클래스뒤에 final 선언하면 상속금지선언



가상함수의 이름과 매개변수타입, 개수 뿐만 아니라 리턴타입도 일치해야 오버라이딩이 성공



무력화되어있지만 살아는있다 ㅋㅋㅋ
말을 못하고 있는상황이지 묻어버린건아님 ㄹㅇㅋㅋ


아부지 청소 쓰고 내청소쓸거라고 한다면 범위지정연산자로 둘다 써줄수있음
물론 오버라이딩되서 무시되고 그다음에 부모클래스 범위의 함수를 호출하는거긴하지만


자식클래스의 포인터 = 업캐스팅된 


소멸자가 가상함수가 아닌경우
-> 자식의 객체를 죽이면 정상적인 소멸이 안됨? 


Base *p = new Derived();
컴파일러는 ~Base() 소멸자만 호출하여 실행한다
생성된 Derived 객체에 대한 소멸자 ~Derived()는실행안된다.

생성자순서 = 부모클래스-> 자식클래스

그래서 소멸자를 가상함수로 한다?

소멸자를 가상함수로 선언하면
부모 뒤지기 직전에 무력화시켜서 자식부터 죽여버린다


자식클래스의 소멸자가 자신의 소멸자 실행후
컴파일러가 부모클래스의 소멸자를 실행하도록 만들었다. 

